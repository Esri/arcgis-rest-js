{"version":3,"file":"micro-memoize.esm.js","sources":["../src/utils.ts","../src/Cache.ts","../src/index.ts"],"sourcesContent":["import { Dictionary, MicroMemoize } from './types';\n\n/**\n * @constant DEFAULT_OPTIONS_KEYS the default options keys\n */\nconst DEFAULT_OPTIONS_KEYS: Dictionary<true> = {\n  isEqual: true,\n  isMatchingKey: true,\n  isPromise: true,\n  maxSize: true,\n  onCacheAdd: true,\n  onCacheChange: true,\n  onCacheHit: true,\n  transformKey: true,\n};\n\n/**\n * @function slice\n *\n * @description\n * slice.call() pre-bound\n */\nexport const { slice } = Array.prototype;\n\n/**\n * @function cloneArray\n *\n * @description\n * clone the array-like object and return the new array\n *\n * @param arrayLike the array-like object to clone\n * @returns the clone as an array\n */\nexport function cloneArray(arrayLike: any[] | IArguments) {\n  const { length } = arrayLike;\n\n  if (!length) {\n    return [];\n  }\n\n  if (length === 1) {\n    return [arrayLike[0]];\n  }\n\n  if (length === 2) {\n    return [arrayLike[0], arrayLike[1]];\n  }\n\n  if (length === 3) {\n    return [arrayLike[0], arrayLike[1], arrayLike[2]];\n  }\n\n  return slice.call(arrayLike, 0);\n}\n\n/**\n * @function getCustomOptions\n *\n * @description\n * get the custom options on the object passed\n *\n * @param options the memoization options passed\n * @returns the custom options passed\n */\nexport function getCustomOptions(options: MicroMemoize.Options) {\n  const customOptions: MicroMemoize.Options = {};\n\n  /* eslint-disable no-restricted-syntax */\n\n  for (const key in options) {\n    if (!DEFAULT_OPTIONS_KEYS[key]) {\n      customOptions[key] = options[key];\n    }\n  }\n\n  /* eslint-enable */\n\n  return customOptions;\n}\n\n/**\n * @function isMemoized\n *\n * @description\n * is the function passed already memoized\n *\n * @param fn the function to test\n * @returns is the function already memoized\n */\nexport function isMemoized(fn: any): fn is MicroMemoize.Memoized<Function> {\n  return (\n    typeof fn === 'function' &&\n    (fn as MicroMemoize.Memoized<Function>).isMemoized\n  );\n}\n\n/**\n * @function isSameValueZero\n *\n * @description\n * are the objects equal based on SameValueZero equality\n *\n * @param object1 the first object to compare\n * @param object2 the second object to compare\n * @returns are the two objects equal\n */\nexport function isSameValueZero(object1: any, object2: any) {\n  // eslint-disable-next-line no-self-compare\n  return object1 === object2 || (object1 !== object1 && object2 !== object2);\n}\n\n/**\n * @function mergeOptions\n *\n * @description\n * merge the options into the target\n *\n * @param existingOptions the options provided\n * @param newOptions the options to include\n * @returns the merged options\n */\nexport function mergeOptions(\n  existingOptions: MicroMemoize.NormalizedOptions,\n  newOptions: MicroMemoize.Options,\n): Readonly<MicroMemoize.NormalizedOptions> {\n  // @ts-ignore\n  const target: MicroMemoize.NormalizedOptions = {};\n\n  /* eslint-disable no-restricted-syntax */\n\n  for (const key in existingOptions) {\n    target[key] = existingOptions[key];\n  }\n\n  for (const key in newOptions) {\n    target[key] = newOptions[key];\n  }\n\n  /* eslint-enable */\n\n  return target;\n}\n","import { MicroMemoize } from './types';\n\n// utils\nimport { cloneArray } from './utils';\n\nexport class Cache {\n  readonly canTransformKey: boolean;\n\n  readonly getKeyIndex: MicroMemoize.KeyIndexGetter;\n\n  readonly options: MicroMemoize.NormalizedOptions;\n\n  readonly shouldCloneArguments: boolean;\n\n  readonly shouldUpdateOnAdd: boolean;\n\n  readonly shouldUpdateOnChange: boolean;\n\n  readonly shouldUpdateOnHit: boolean;\n\n  keys: MicroMemoize.Key[];\n\n  values: MicroMemoize.Value[];\n\n  constructor(options: MicroMemoize.NormalizedOptions) {\n    this.keys = [];\n    this.values = [];\n    this.options = options;\n\n    const isMatchingKeyFunction = typeof options.isMatchingKey === 'function';\n\n    if (isMatchingKeyFunction) {\n      this.getKeyIndex = this._getKeyIndexFromMatchingKey;\n    } else if (options.maxSize > 1) {\n      this.getKeyIndex = this._getKeyIndexForMany;\n    } else {\n      this.getKeyIndex = this._getKeyIndexForSingle;\n    }\n\n    this.canTransformKey = typeof options.transformKey === 'function';\n    this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;\n\n    this.shouldUpdateOnAdd = typeof options.onCacheAdd === 'function';\n    this.shouldUpdateOnChange = typeof options.onCacheChange === 'function';\n    this.shouldUpdateOnHit = typeof options.onCacheHit === 'function';\n  }\n\n  get size() {\n    return this.keys.length;\n  }\n\n  get snapshot() {\n    return {\n      keys: cloneArray(this.keys),\n      size: this.size,\n      values: cloneArray(this.values),\n    };\n  }\n\n  /**\n   * @function _getKeyIndexFromMatchingKey\n   *\n   * @description\n   * gets the matching key index when a custom key matcher is used\n   *\n   * @param keyToMatch the key to match\n   * @returns the index of the matching key, or -1\n   */\n  _getKeyIndexFromMatchingKey(keyToMatch: MicroMemoize.RawKey) {\n    const { isMatchingKey, maxSize } = this.options as {\n      isMatchingKey: MicroMemoize.MatchingKeyComparator;\n      maxSize: number;\n    };\n\n    const { keys } = this;\n    const keysLength = keys.length;\n\n    if (!keysLength) {\n      return -1;\n    }\n\n    if (isMatchingKey(keys[0], keyToMatch)) {\n      return 0;\n    }\n\n    if (maxSize > 1) {\n      for (let index = 1; index < keysLength; index++) {\n        if (isMatchingKey(keys[index], keyToMatch)) {\n          return index;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * @function _getKeyIndexForMany\n   *\n   * @description\n   * gets the matching key index when multiple keys are used\n   *\n   * @param keyToMatch the key to match\n   * @returns the index of the matching key, or -1\n   */\n  _getKeyIndexForMany(keyToMatch: MicroMemoize.RawKey) {\n    const { isEqual } = this.options;\n\n    const { keys } = this;\n    const keysLength = keys.length;\n\n    if (!keysLength) {\n      return -1;\n    }\n\n    if (keysLength === 1) {\n      return this._getKeyIndexForSingle(keyToMatch);\n    }\n\n    const keyLength = keyToMatch.length;\n\n    let existingKey;\n    let argIndex;\n\n    if (keyLength > 1) {\n      for (let index = 0; index < keysLength; index++) {\n        existingKey = keys[index];\n\n        if (existingKey.length === keyLength) {\n          argIndex = 0;\n\n          for (; argIndex < keyLength; argIndex++) {\n            if (!isEqual(existingKey[argIndex], keyToMatch[argIndex])) {\n              break;\n            }\n          }\n\n          if (argIndex === keyLength) {\n            return index;\n          }\n        }\n      }\n    } else {\n      for (let index = 0; index < keysLength; index++) {\n        existingKey = keys[index];\n\n        if (\n          existingKey.length === keyLength &&\n          isEqual(existingKey[0], keyToMatch[0])\n        ) {\n          return index;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * @function _getKeyIndexForSingle\n   *\n   * @description\n   * gets the matching key index when a single key is used\n   *\n   * @param keyToMatch the key to match\n   * @returns the index of the matching key, or -1\n   */\n  _getKeyIndexForSingle(keyToMatch: MicroMemoize.RawKey) {\n    const { keys } = this;\n\n    if (!keys.length) {\n      return -1;\n    }\n\n    const existingKey = keys[0];\n    const { length } = existingKey;\n\n    if (keyToMatch.length !== length) {\n      return -1;\n    }\n\n    const { isEqual } = this.options;\n\n    if (length > 1) {\n      for (let index = 0; index < length; index++) {\n        if (!isEqual(existingKey[index], keyToMatch[index])) {\n          return -1;\n        }\n      }\n\n      return 0;\n    }\n\n    return isEqual(existingKey[0], keyToMatch[0]) ? 0 : -1;\n  }\n\n  /**\n   * @function orderByLru\n   *\n   * @description\n   * order the array based on a Least-Recently-Used basis\n   *\n   * @param key the new key to move to the front\n   * @param value the new value to move to the front\n   * @param startingIndex the index of the item to move to the front\n   */\n  orderByLru(\n    key: MicroMemoize.Key,\n    value: MicroMemoize.Value,\n    startingIndex: number,\n  ) {\n    const { keys } = this;\n    const { values } = this;\n\n    const currentLength = keys.length;\n\n    let index = startingIndex;\n\n    while (index--) {\n      keys[index + 1] = keys[index];\n      values[index + 1] = values[index];\n    }\n\n    keys[0] = key;\n    values[0] = value;\n\n    const { maxSize } = this.options;\n\n    if (currentLength === maxSize && startingIndex === currentLength) {\n      keys.pop();\n      values.pop();\n    } else if (startingIndex >= maxSize) {\n      // eslint-disable-next-line no-multi-assign\n      keys.length = values.length = maxSize;\n    }\n  }\n\n  /**\n   * @function updateAsyncCache\n   *\n   * @description\n   * update the promise method to auto-remove from cache if rejected, and\n   * if resolved then fire cache hit / changed\n   *\n   * @param memoized the memoized function\n   */\n  updateAsyncCache(memoized: MicroMemoize.Memoized<Function>) {\n    const { onCacheChange, onCacheHit } = this.options as {\n      onCacheChange: MicroMemoize.CacheModifiedHandler;\n      onCacheHit: MicroMemoize.CacheModifiedHandler;\n    };\n\n    const [firstKey] = this.keys;\n    const [firstValue] = this.values;\n\n    this.values[0] = firstValue.then(\n      (value: any) => {\n        if (this.shouldUpdateOnHit) {\n          onCacheHit(this, this.options, memoized);\n        }\n\n        if (this.shouldUpdateOnChange) {\n          onCacheChange(this, this.options, memoized);\n        }\n\n        return value;\n      },\n      (error: Error) => {\n        const keyIndex = this.getKeyIndex(firstKey);\n\n        if (keyIndex !== -1) {\n          this.keys.splice(keyIndex, 1);\n          this.values.splice(keyIndex, 1);\n        }\n\n        throw error;\n      },\n    );\n  }\n}\n","// cache\nimport { Cache } from './Cache';\n\n// types\nimport { MicroMemoize } from './types';\n\n// utils\nimport {\n  cloneArray,\n  getCustomOptions,\n  isMemoized,\n  isSameValueZero,\n  mergeOptions,\n} from './utils';\n\nfunction createMemoizedFunction<Fn extends Function>(\n  fn: Fn | MicroMemoize.Memoized<Fn>,\n  options: MicroMemoize.Options = {},\n): MicroMemoize.Memoized<Fn> {\n  if (isMemoized(fn)) {\n    return createMemoizedFunction(fn.fn, mergeOptions(fn.options, options));\n  }\n\n  if (typeof fn !== 'function') {\n    throw new TypeError('You must pass a function to `memoize`.');\n  }\n\n  const {\n    isEqual = isSameValueZero,\n    isMatchingKey,\n    isPromise = false,\n    maxSize = 1,\n    onCacheAdd,\n    onCacheChange,\n    onCacheHit,\n    transformKey,\n  } = options;\n\n  const normalizedOptions = mergeOptions(\n    {\n      isEqual,\n      isMatchingKey,\n      isPromise,\n      maxSize,\n      onCacheAdd,\n      onCacheChange,\n      onCacheHit,\n      transformKey,\n    },\n    getCustomOptions(options),\n  );\n\n  const cache = new Cache(normalizedOptions);\n\n  const {\n    keys,\n    values,\n    canTransformKey,\n    shouldCloneArguments,\n    shouldUpdateOnAdd,\n    shouldUpdateOnChange,\n    shouldUpdateOnHit,\n  } = cache;\n\n  // @ts-ignore\n  const memoized: Memoized<Fn> = function memoized(this) {\n    // @ts-ignore\n    let key: MicroMemoize.Key = shouldCloneArguments\n      ? cloneArray(arguments)\n      : arguments;\n\n    if (canTransformKey) {\n      key = (transformKey as MicroMemoize.KeyTransformer)(key);\n    }\n\n    const keyIndex = keys.length ? cache.getKeyIndex(key) : -1;\n\n    if (keyIndex !== -1) {\n      if (shouldUpdateOnHit) {\n        (onCacheHit as MicroMemoize.CacheModifiedHandler)(\n          cache,\n          normalizedOptions,\n          memoized,\n        );\n      }\n\n      if (keyIndex) {\n        cache.orderByLru(keys[keyIndex], values[keyIndex], keyIndex);\n\n        if (shouldUpdateOnChange) {\n          (onCacheChange as MicroMemoize.CacheModifiedHandler)(\n            cache,\n            normalizedOptions,\n            memoized,\n          );\n        }\n      }\n    } else {\n      const newValue = fn.apply(this, arguments);\n      const newKey = shouldCloneArguments\n        ? (key as any[])\n        : cloneArray(arguments);\n\n      cache.orderByLru(newKey, newValue, keys.length);\n\n      if (isPromise) {\n        cache.updateAsyncCache(memoized);\n      }\n\n      if (shouldUpdateOnAdd) {\n        (onCacheAdd as MicroMemoize.CacheModifiedHandler)(\n          cache,\n          normalizedOptions,\n          memoized,\n        );\n      }\n\n      if (shouldUpdateOnChange) {\n        (onCacheChange as MicroMemoize.CacheModifiedHandler)(\n          cache,\n          normalizedOptions,\n          memoized,\n        );\n      }\n    }\n\n    return values[0];\n  };\n\n  memoized.cache = cache;\n  memoized.fn = fn;\n  memoized.isMemoized = true as const;\n  memoized.options = normalizedOptions;\n\n  return memoized;\n}\n\nexport default createMemoizedFunction;\n"],"names":[],"mappings":"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"}