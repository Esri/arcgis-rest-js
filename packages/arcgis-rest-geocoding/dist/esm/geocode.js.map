{"version":3,"file":"geocode.js","sourceRoot":"","sources":["../../src/geocode.ts"],"names":[],"mappings":"AAAA;gBACgB;AAEhB,OAAO,EACL,OAAO,EACP,QAAQ,EACR,kBAAkB,EAInB,MAAM,2BAA2B,CAAC;AAEnC,OAAO,EAAE,2BAA2B,EAAoB,MAAM,cAAc,CAAC;AAE7E,OAAO,EAAE,eAAe,EAAE,MAAM,qBAAqB,CAAC;AA0DtD;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,UAAU,OAAO,CACrB,OAAiC;IAEjC,IAAI,OAAO,GAAoB,EAAE,CAAC;IAClC,IAAI,QAAgB,CAAC;IAErB,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;QAC/B,OAAO,CAAC,MAAM,GAAG,EAAE,UAAU,EAAE,OAAO,EAAE,CAAC;QACzC,QAAQ,GAAG,2BAA2B,CAAC;KACxC;SAAM;QACL,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,2BAA2B,CAAC;QAC3D,OAAO,GAAG,kBAAkB,CAC1B,OAAO,EACP;YACE,YAAY;YACZ,SAAS;YACT,UAAU;YACV,UAAU;YACV,cAAc;YACd,MAAM;YACN,WAAW;YACX,QAAQ;YACR,QAAQ;YACR,WAAW;YACX,aAAa;YACb,WAAW;YACX,UAAU;SACX,EACD,EAAE,MAAM,oBAAO,OAAO,CAAC,MAAM,CAAE,EAAE,CAClC,CAAC;KACH;IAED,sDAAsD;IACtD,OAAO,OAAO,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,wBAAwB,EAAE,OAAO,CAAC,CAAC,IAAI,CACzE,CAAC,QAAQ,EAAE,EAAE;QACX,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,CAAC,WAAW,EAAE;YACtD,OAAO,QAAQ,CAAC;SACjB;QACD,MAAM,EAAE,GAAsB,QAAQ,CAAC,gBAAgB,CAAC;QACxD,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,UAAU,SAGrC;YACC,SAAS,CAAC,QAAQ,CAAC,gBAAgB,GAAG,EAAE,CAAC;YACzC,IAAI,SAAS,CAAC,MAAM,EAAE;gBACpB,SAAS,CAAC,MAAM,CAAC,gBAAgB,GAAG,EAAE,CAAC;aACxC;QACH,CAAC,CAAC,CAAC;QAEH,UAAU;QACV,IAAI,EAAE,CAAC,IAAI,KAAK,IAAI,EAAE;YACpB,MAAM,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,SAAc,EAAE,EAAE;gBAC1D,OAAO;oBACL,IAAI,EAAE,SAAS;oBACf,QAAQ,EAAE,eAAe,CAAC,SAAS,CAAC,QAAQ,CAAC;oBAC7C,UAAU,EAAE,MAAM,CAAC,MAAM,CACvB;wBACE,OAAO,EAAE,SAAS,CAAC,OAAO;wBAC1B,KAAK,EAAE,SAAS,CAAC,KAAK;qBACvB,EACD,SAAS,CAAC,UAAU,CACrB;iBACF,CAAC;YACJ,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,OAAO,GAAG;gBACjB,IAAI,EAAE,mBAAmB;gBACzB,QAAQ;aACT,CAAC;SACH;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC,CACF,CAAC;AACJ,CAAC","sourcesContent":["/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  appendCustomParams,\n  IExtent,\n  ISpatialReference,\n  IPoint\n} from \"@esri/arcgis-rest-request\";\n\nimport { ARCGIS_ONLINE_GEOCODING_URL, IEndpointOptions } from \"./helpers.js\";\n\nimport { arcgisToGeoJSON } from \"@terraformer/arcgis\";\n\nexport interface IGeocodeOptions extends IEndpointOptions {\n  /**\n   * use this if all your address info is contained in a single string.\n   */\n  singleLine?: string;\n  address?: string;\n  address2?: string;\n  address3?: string;\n  neighborhood?: string;\n  city?: string;\n  subregion?: string;\n  outFields?: \"*\" | string[];\n  /**\n   * The World Geocoding Service expects US states to be passed in as a 'region'.\n   */\n  region?: string;\n  postal?: number;\n  postalExt?: number;\n  countryCode?: string;\n  /**\n   * You can create an autocomplete experience by making a call to suggest with partial text and then passing through the magicKey and complete address that are returned to geocode.\n   *\n   * ```js\n   * import { suggest, geocode } from '@esri/arcgis-rest-geocoding';\n   *\n   * suggest(\"LAX\")\n   *   .then((response) => {\n   *     geocode({\n   *       singleLine: response.suggestions[1].text,\n   *       magicKey: response.suggestions[0].magicKey\n   *     })\n   *   })\n   * ```\n   */\n  magicKey?: string;\n}\n\nexport interface IGeocodeResponse {\n  spatialReference: ISpatialReference;\n  candidates: Array<{\n    address: string;\n    location: IPoint;\n    extent?: IExtent;\n    score: number;\n    attributes: object;\n  }>;\n  geoJson?: {\n    type: string;\n    features: Array<{\n      type: string;\n      geometry: object;\n      properties: any;\n    }>;\n  };\n}\n\n/**\n * Used to determine the location of a single address or point of interest. See the [REST Documentation](https://developers.arcgis.com/rest/geocode/api-reference/geocoding-find-address-candidates.htm) for more information.\n *\n *  ```js\n * import { geocode } from '@esri/arcgis-rest-geocoding';\n *\n * geocode(\"LAX\")\n *   .then((response) => {\n *     response.candidates[0].location; // => { x: -118.409, y: 33.943, spatialReference: ...  }\n *   });\n *\n * geocode({\n *   address: \"1600 Pennsylvania Ave\",\n *   postal: 20500,\n *   countryCode: \"USA\"\n * })\n *   .then((response) => {\n *     response.candidates[1].location; // => { x: -77.036533, y: 38.898719, spatialReference: ... }\n *   });\n * ```\n *\n * @param address String representing the address or point of interest or RequestOptions to pass to the endpoint.\n * @returns A Promise that will resolve with address candidates for the request. The spatial reference will be added to candidate locations and extents unless `rawResponse: true` was passed.\n */\nexport function geocode(\n  address: string | IGeocodeOptions\n): Promise<IGeocodeResponse> {\n  let options: IGeocodeOptions = {};\n  let endpoint: string;\n\n  if (typeof address === \"string\") {\n    options.params = { singleLine: address };\n    endpoint = ARCGIS_ONLINE_GEOCODING_URL;\n  } else {\n    endpoint = address.endpoint || ARCGIS_ONLINE_GEOCODING_URL;\n    options = appendCustomParams<IGeocodeOptions>(\n      address,\n      [\n        \"singleLine\",\n        \"address\",\n        \"address2\",\n        \"address3\",\n        \"neighborhood\",\n        \"city\",\n        \"subregion\",\n        \"region\",\n        \"postal\",\n        \"postalExt\",\n        \"countryCode\",\n        \"outFields\",\n        \"magicKey\"\n      ],\n      { params: { ...address.params } }\n    );\n  }\n\n  // add spatialReference property to individual matches\n  return request(`${cleanUrl(endpoint)}/findAddressCandidates`, options).then(\n    (response) => {\n      if (typeof address !== \"string\" && address.rawResponse) {\n        return response;\n      }\n      const sr: ISpatialReference = response.spatialReference;\n      response.candidates.forEach(function (candidate: {\n        location: IPoint;\n        extent?: IExtent;\n      }) {\n        candidate.location.spatialReference = sr;\n        if (candidate.extent) {\n          candidate.extent.spatialReference = sr;\n        }\n      });\n\n      // geoJson\n      if (sr.wkid === 4326) {\n        const features = response.candidates.map((candidate: any) => {\n          return {\n            type: \"Feature\",\n            geometry: arcgisToGeoJSON(candidate.location),\n            properties: Object.assign(\n              {\n                address: candidate.address,\n                score: candidate.score\n              },\n              candidate.attributes\n            )\n          };\n        });\n\n        response.geoJson = {\n          type: \"FeatureCollection\",\n          features\n        };\n      }\n\n      return response;\n    }\n  );\n}\n"]}