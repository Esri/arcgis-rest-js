{"version":3,"file":"app-tokens.js","sourceRoot":"","sources":["../../src/app-tokens.ts"],"names":[],"mappings":";AAAA;gBACgB;;;AAEhB,6CAAuC;AAGvC;;;;;;;;;;;;;;;;;;GAkBG;AACH,SAAgB,aAAa,CAC3B,KAAa,EACb,QAAgB,EAChB,MAAM,GAAG,qCAAqC;IAE9C,MAAM,GAAG,GAAG,GAAG,MAAM,uBAAuB,CAAC;IAC7C,MAAM,EAAE,GAAG;QACT,MAAM,EAAE,MAAM;QACd,MAAM,EAAE;YACN,CAAC,EAAE,MAAM;YACT,SAAS,EAAE,QAAQ;YACnB,KAAK;SACN;KACiB,CAAC;IACrB,wCAAwC;IACxC,OAAO,IAAA,oBAAO,EAAC,GAAG,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AAC7D,CAAC;AAhBD,sCAgBC;AAqBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+CG;AACH,SAAgB,YAAY,CAC1B,QAAgB,EAChB,WAAmB,EACnB,MAAM,GAAG,qCAAqC;IAE9C,+DAA+D;IAC/D,MAAM,GAAG,GAAG,GAAG,MAAM,6BAA6B,CAAC;IACnD,MAAM,EAAE,GAAG;QACT,MAAM,EAAE,MAAM;QACd,OAAO,EAAE;YACP,uBAAuB,EAAE,QAAQ;YACjC,0BAA0B,EAAE,WAAW;SACxC;QACD,gDAAgD;QAChD,6DAA6D;QAC7D,MAAM,EAAE;YACN,CAAC,EAAE,MAAM;SACV;KACiB,CAAC;IACrB,wCAAwC;IACxC,OAAO,IAAA,oBAAO,EAAC,GAAG,EAAE,EAAE,CAAC,CAAC;AAC1B,CAAC;AArBD,oCAqBC","sourcesContent":["/* Copyright (c) 2018-2020 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { request } from \"./request.js\";\nimport { IRequestOptions } from \"./utils/IRequestOptions.js\";\n\n/**\n * Request app-specific token, passing in the token for the current app.\n *\n * This call returns a token after performing the same checks made by validateAppAccess.\n * It returns an app-specific token of the signed-in user only if the user has access\n * to the app and the encrypted platform cookie is valid.\n *\n * A scenario where an app would use this is if it is iframed into another platform app\n * and receives credentials via postMessage. Those credentials contain a token that is\n * specific to the host app, so the embedded app would use `exchangeToken` to get one\n * that is specific to itself.\n *\n * Note: This is only usable by Esri applications hosted on *arcgis.com, *esri.com or within\n * an ArcGIS Enterprise installation. Custom applications can not use this.\n *\n * @param token\n * @param clientId application\n * @param portal\n */\nexport function exchangeToken(\n  token: string,\n  clientId: string,\n  portal = \"https://www.arcgis.com/sharing/rest\"\n): Promise<string> {\n  const url = `${portal}/oauth2/exchangeToken`;\n  const ro = {\n    method: \"POST\",\n    params: {\n      f: \"json\",\n      client_id: clientId,\n      token\n    }\n  } as IRequestOptions;\n  // make the request and return the token\n  return request(url, ro).then((response) => response.token);\n}\n\n/**\n * Response from the `platformSelf(...)` function.\n */\nexport interface IPlatformSelfResponse {\n  /**\n   * Username of the user the encrypted cookie was issued for\n   */\n  username: string;\n  /**\n   * Token the consuming application can use, It is tied to the\n   * clientId used in the `platformSelf` call\n   */\n  token: string;\n  /**\n   * Token expiration, in seconds-from-now\n   */\n  expires_in: number;\n}\n\n/**\n * Request a token for a specific application using the esri_aopc encrypted cookie\n *\n * When a client app boots up, it will know its clientId and the redirectUri for use\n * in the normal /oauth/authorize pop-out oAuth flow.\n *\n * If the app sees an `esri_aopc` cookie (only set if the app is hosted on *.arcgis.com),\n * it can call the /oauth2/platformSelf end-point passing in the clientId and redirectUri\n * in headers, and it will receive back an app-specific token, assuming the user has\n * access to the app.\n *\n * Since there are scenarios where an app can boot using credentials/token from localstorage\n * but those credentials are not for the same user as the esri_aopc cookie, it is recommended that\n * an app check the returned username against any existing identity they may have loaded.\n *\n * Note: This is only usable by Esri applications hosted on *arcgis.com, *esri.com or within\n * an ArcGIS Enterprise installation. Custom applications can not use this.\n *\n * ```js\n * // convert the encrypted platform cookie into a ArcGISIdentityManager\n * import { platformSelf, ArcGISIdentityManager } from '@esri/arcgis-rest-request';\n *\n * const portal = 'https://www.arcgis.com/sharing/rest';\n * const clientId = 'YOURAPPCLIENTID';\n *\n * // exchange esri_aopc cookie\n * return platformSelf(clientId, 'https://your-app-redirect-uri', portal)\n * .then((response) => {\n *  const currentTimestamp = new Date().getTime();\n *  const tokenExpiresTimestamp = currentTimestamp + (response.expires_in * 1000);\n *  // Construct the session and return it\n *  return new ArcGISIdentityManager({\n *    portal,\n *    clientId,\n *    username: response.username,\n *    token: response.token,\n *    tokenExpires: new Date(tokenExpiresTimestamp),\n *    ssl: true\n *  });\n * })\n *\n * ```\n *\n *\n * @param clientId\n * @param redirectUri\n * @param portal\n */\nexport function platformSelf(\n  clientId: string,\n  redirectUri: string,\n  portal = \"https://www.arcgis.com/sharing/rest\"\n): Promise<IPlatformSelfResponse> {\n  // TEMPORARY: the f=json should not be needed, but currently is\n  const url = `${portal}/oauth2/platformSelf?f=json`;\n  const ro = {\n    method: \"POST\",\n    headers: {\n      \"X-Esri-Auth-Client-Id\": clientId,\n      \"X-Esri-Auth-Redirect-Uri\": redirectUri\n    },\n    // Note: request has logic to include the cookie\n    // for platformSelf calls w/ the X-Esri-Auth-Client-Id header\n    params: {\n      f: \"json\"\n    }\n  } as IRequestOptions;\n  // make the request and return the token\n  return request(url, ro);\n}\n"]}