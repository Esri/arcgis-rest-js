<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">

  <style>
    html,
    body {
      margin: 0;
    }

    #map {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 14px;
      color: #323232;
    }

    #view-session-button {
      position: absolute;
      top: 15px;
      left: 15px;
      z-index: 100;
    }

    #timer {
      position: absolute;
      top: 15px;
      right: 15px;
      font-size: 20px;
      font-family: "Orbitron";
      background-color: white;
      padding: 3px 5px;
      z-index: 100;
    }
  </style>
  <!-- Map package imports to URLS starting with @esri/... which will get served from the local build of the modules -->
  <script type="importmap">
        {
          "imports": {
            "@esri/arcgis-rest-request": "/@esri/arcgis-rest-request/dist/bundled/request.esm.js",
            "@esri/arcgis-rest-basemap-sessions": "/@esri/arcgis-rest-basemap-sessions/dist/bundled/basemap-sessions.esm.js"
          }
        }
      </script>
  <link href='https://fonts.googleapis.com/css?family=Orbitron' rel='stylesheet' type='text/css'>
  <script type="module" src=https://js.arcgis.com/calcite-components/3.2.1/calcite.esm.js></script>
  <script src=https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.js></script>
  <link href=https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.css rel="stylesheet" />

</head>

<body>
  <calcite-dialog modal heading="Welcome to Day Mapper " id="session-dialog">
    <div>You are about to start your session. Restart the application at anytime!</div>
    <br />
    <div id="time"></div>
    <calcite-button id="continue-button" slot="footer-end" appearance="outline">
      Continue
    </calcite-button>
    <calcite-button id="start-button" slot="footer-end">
      Start new session
    </calcite-button>
    <calcite-button id="save-button" slot="footer-end">
      Save
    </calcite-button>
    <calcite-button id="delete-button" slot="footer-end">
      Delete
    </calcite-button>
    <calcite-button id="refresh-button" slot="footer-end">
      Refresh
    </calcite-button>
    <calcite-button id="reset-button" slot="footer-start" kind="neutral">
      Reset map
    </calcite-button>
    <calcite-button id="clear-button" slot="footer-start" kind="neutral">
      Clear map
    </calcite-button>
  </calcite-dialog>
  <calcite-button id="view-session-button">View map session</calcite-button>
  <div id="timer"></div>
  <div id="map"></div>

  <script type="module">
    import { StaticBasemapTilesSession } from "@esri/arcgis-rest-basemap-sessions";
    import { ApiKeyManager } from "@esri/arcgis-rest-request";

    const appId = "__ARCGIS_SESSION_APP__";
    const accessToken = "Your API Key Here"; // Replace with your API key

    const sessionToken = null;
    const defaultMapSettings = {
      center: [-10, 30],
      zoom: 2,
      pitch: 0,
      bearing: 0
    }

    const app = {
      map: null,
      busy: false,
      timerInterval: null
    }

    let appState = {
      session: null,  // tokenObject
      mapSettings: {
        center: [],
        zoom: 0,
        pitch: 0,
        bearing: 0,
      }
    }

    const viewButton = document.getElementById("view-session-button");
    const startButton = document.getElementById("start-button");
    const saveButton = document.getElementById("save-button");
    const deleteButton = document.getElementById("delete-button");
    const continueButton = document.getElementById("continue-button");
    const resetButton = document.getElementById("reset-button");
    const clearButton = document.getElementById("clear-button");
    const refreshButton = document.getElementById("refresh-button");
    const time = document.getElementById("time");
    const dialog = document.getElementById("session-dialog");
    const timer = document.getElementById("timer");

    // Dialog
    dialog.addEventListener("calciteDialogBeforeOpen", function () {
      if (appState.session && appState.session.endTime) {
        const endDate = new Date(appState.session.endTime)
        time.innerText = "Time left: " + Math.round((endDate - Date.now()) / 1000) + " seconds";
      }
    })

    // dialog.addEventListener("calciteDialogClose",  function() {
    // })

    // View
    viewButton?.addEventListener("click", function () {
      dialog.open = true;
    });
    // Start new session
    startButton?.addEventListener("click", function () {
      dialog.open = false;
      unloadState(); // Remove state
      loadApp();
    });
    // Save
    saveButton?.addEventListener("click", function () {
      dialog.open = false;
      saveState();
    });
    // Delete
    deleteButton?.addEventListener("click", function () {
      dialog.open = false;
      unloadState();
      unloadMap();
      if (app.timerInterval) {
        clearInterval(app.timerInterval);
        document.getElementById("timer").innerHTML = "";
      }
    });
    // Continue
    continueButton?.addEventListener("click", function () {
      dialog.open = false;
      loadApp();
    });
    // Reset map
    resetButton?.addEventListener("click", function () {
      dialog.open = false;
      unloadMap();
      const mapSettings = { ...appState.mapSettings, center: defaultMapSettings.center, zoom: defaultMapSettings.zoom, pitch: defaultMapSettings.pitch, bearing: defaultMapSettings.bearing }
      updateAppState(appState.session, mapSettings);
      loadMap()
    });
    // Clear map
    clearButton?.addEventListener("click", function () {
      dialog.open = false;
      unloadMap();
    });
    // Refresh (timer only)
    refreshButton?.addEventListener("click", function () {
      dialog.open = false;
      dialog.open = true;
    });

    // Apply state
    async function loadApp() {
      const appState = await initState();

      updateAppState(appState.session, appState.mapSettings);

      appState.session.on("expired", refreshToken);
      appState.session.on("refreshed", handleRefresh);
      document.addEventListener("visibilitychange", handleVisibilityChange);

      saveState(); // Do this now or later
      loadMap();
      startCountdown(); // Start the countdown timer

      return appState;
    }

    function unloadApp() {
      unloadMap();
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    }

    function handleVisibilityChange() {
      if (document.visibilityState === 'hidden') {
        // Save state when the document is hidden
        console.log("Document hidden, saving state");
        saveState();
      } else if (document.visibilityState === 'visible') {
        // Check if the session is expired when the document becomes visible
        console.log("Document visible, checking session expiration");
        appState.session.isSessionExpired();
      }
    }

    // Initialize the state either from localStorage or create a new session
    async function initState() {
      const savedState = localStorage.getItem(appId);
      if (!savedState) {
        const session = await BasemapStyleSession.start({
          authentication: accessToken,
          testSession: true,
          safetyMargin: 1
        });

        return {
          session: session,
          mapSettings: defaultMapSettings
        };
      }

      const state = JSON.parse(savedState);
      state.session = new BasemapStyleSession(state.session);

      return {
        session: state.session,
        mapSettings: state.mapSettings || defaultMapSettings
      };
    }

    function refreshToken(e) {
      appState.session.refreshCredentials();
    }

    async function handleRefresh(e) {
      const newToken = e.current.token;
      const oldToken = e.previous.token;

      startCountdown(); // Restart the countdown timer

      if (!app.map) {
        console.log("Map not loaded ignoring refresh");
        return;
      }

      const source = app.map.getSource("esri");

      console.log("Refreshing map source with new token", { tiles: source.tiles });

      const newTiles = source.tiles.map(tileUrl => {
        return tileUrl.includes(oldToken) ? tileUrl.replace(oldToken, newToken) : tileUrl;
      });
      source.setTiles(newTiles);
    };

    function saveState() {
      localStorage.removeItem(appId);
      localStorage.setItem(appId, JSON.stringify(appState));
      console.log("Saving state: ", appState)
    }

    function unloadState() {
      localStorage.removeItem(appId);
    }

    function updateAppState(session, mapSettings) {
      appState.session = session;
      appState.mapSettings = mapSettings;
      // Log state change
      console.log("Updating appState:", appState)
    }

    function resetAppState() {
      appState.session = null;
      appState.mapSettings = defaultMapSettings;
    }

    // Map
    async function loadMap() {
      // this will refresh if neccessary so we can always call it to ensure we have a valid session token
      // this also means that the refresh event might be called before the map is loaded if we load the app after a session expires
      const sessionToken = await appState.session.getToken();
      console.log("Loading map with session token:", sessionToken);

      // using session token is strange here because it will get attavhed to gylphs and sprites
      // ideally this maplibre-gl map should be created with the api key and we should use the session
      // token for the basemap styles service ant swap the session tonken in the map source
      const devBasemapStyles = "https://basemapstylesdev-api.arcgis.com/arcgis/rest/services/styles/v2/styles"
      const basemapEnum = 'arcgis/outdoor';
      const basemapUrl = `${devBasemapStyles}/${basemapEnum}?token=${sessionToken}`;

      // Create map
      if (app.map) {
        unloadMap();
      }

      app.map = new maplibregl.Map({
        container: 'map',
        style: basemapUrl,
        zoom: appState.mapSettings.zoom,
        center: appState.mapSettings.center,
        pitch: appState.mapSettings.pitch,
        bearing: appState.mapSettings.bearing
      });

      app.map.on("load", () => {
        console.log("Map loaded successfully");
        app.map.addSource('big-polygon', {
          type: 'geojson',
          data: {
            "type": "FeatureCollection",
            "features": [
              {
                "type": "Feature",
                "properties": {},
                "geometry": {
                  "coordinates": [
                    [
                      [
                        186.9921874999967,
                        43.67581809328351
                      ],
                      [
                        103.14453124999841,
                        63.45050921800103
                      ],
                      [
                        4.003906249998693,
                        67.1187484951798
                      ],
                      [
                        -72.46093750000007,
                        54.64841250231663
                      ],
                      [
                        -127.12890624999878,
                        27.800209937418913
                      ],
                      [
                        -111.48437500000003,
                        -32.87958717306474
                      ],
                      [
                        16.83593749999929,
                        -55.00282580979231
                      ],
                      [
                        105.25900405568882,
                        38.746188018915916
                      ],
                      [
                        96.99728530568814,
                        55.918913278550406
                      ],
                      [
                        186.9921874999967,
                        43.67581809328351
                      ]
                    ]
                  ],
                  "type": "Polygon"
                }
              }
            ]
          }
        });

        app.map.addLayer({
          'id': 'big-polygon',
          'type': 'fill',
          'source': 'big-polygon',
          'layout': {},
          'paint': {
            'fill-color': '#000000',
            'fill-opacity': 0.25
          }
        });
      });

      app.map.on("zoomend", (e) => {
        try {
          const mapSettings = { ...appState.mapSettings, center: app.map.getCenter(), zoom: app.map.getZoom(), pitch: app.map.getPitch(), bearing: app.map.getBearing() }
          updateAppState(appState.session, mapSettings);
        } catch (error) {
          console.log(error)
        }
      });

      app.map.on("dragend", (e) => {
        try {
          const mapSettings = { ...appState.mapSettings, center: app.map.getCenter(), zoom: app.map.getZoom(), pitch: app.map.getPitch(), bearing: app.map.getBearing() }
          updateAppState(appState.session, mapSettings);
        } catch (error) {
          console.log(error)
        }
      });

      app.map.on("error", async (e) => {
        console.log("Map error: ", e);
        // Only way I could get this to stop 401'ing
        if (!app.busy && (e.error.status == 401)) {
          appState.session.refreshCredentials();
        }
      })
    }

    function unloadMap() {
      // Force map to unload/undraw to simulate map failure and session is over
      if (app.map) {
        // Destroy
        //app.map.setStyle({ version: 8, sources: {}, layers: [] }, {"diff": false});
        app.map.remove();
        app.map = null;
      }
    }

    function getTimeRemaining(endtime) {
      const total = Date.parse(endtime) - Date.parse(new Date());
      const seconds = Math.max(Math.floor((total / 1000) % 60), 0);
      const minutes = Math.max(Math.floor((total / 1000 / 60) % 60), 0);
      const hours = Math.max(Math.floor((total / (1000 * 60 * 60)) % 24), 0);
      const days = Math.max(Math.floor(total / (1000 * 60 * 60 * 24)), 0);

      return {
        total,
        days,
        hours,
        minutes,
        seconds
      };
    }

    function padNumber(num) {
      return num < 10 ? '0' + num : num;
    }

    function startCountdown() {
      console.log("Starting countdown timer for session: ", appState.session);
      if (!appState.session) {
        return
      }

      if (app.timerInterval) {
        clearInterval(app.timerInterval)
      }

      app.timerInterval = setInterval(function () {
        const { hours, minutes, seconds } = getTimeRemaining(appState.session.endTime);
        var timeString = `${padNumber(hours)}:${padNumber(minutes)}:${padNumber(seconds)}`;
        timer.textContent = timeString;
      }, 100); // Update every 100 millisecondss
    }
  </script>
</body>

</html>